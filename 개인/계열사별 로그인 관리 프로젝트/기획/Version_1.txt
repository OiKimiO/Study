계열사 관리 프로젝트
   - 어떤 목표로 왜 사용하는가?
     * 목표
       # 확장성, 보안, 성능, 협업을 고려한 개발
         - 최신 트렌드 기술을 배우고 프로젝트 적용
           - 적용하는 기술은 어떤 근거로 적용하는지가 명확해야 됨
             - 명확한 근거를 통해 기술을 적용해 최종적으로 사용하는 기술을 자신의 것으로 체화시킬 것
               - 프로젝트 개발시 현업에서 사용하는 프로젝트만큼의 최적화를 할 수는 없음
                 - 그러나 위의 4가지를 고려한 개발을 통해 학습 방식과 개발자적 사고를 키우고자 함
                
   1) Version_1
      - 운영 환경
        * Naver - Cloud Linux 서버
          # 오픈 소스 도구
             > 소프트웨어 라이선스 비용 절감 및 특정 요구사항에 맞게 개발환경 설정 가능
                $ RHEL(Red Hat Enterprise Linux) 등과 같은 리눅스는 비용이 발생할 수 있음
          # 강력한 명령줄 도구
             > 작업을 자동화 하고 시스템을 빠르게 탐색 가능
          # 안정성과 신뢰성
             > 안정과 신뢰성이 뛰어나 생산성 유지 및 프로젝트에 집중 할 수 있음
          # 보안
             > 바이러스와 맬웨어에 덜 취약하기에 다른 운영체제보다 안전
                $ 조금 더 찾아 보기
          # 호환성
             > 웹 개발 도구와 프레임워크가 호환되도록 설계

        * Java 11 진행 
          # 모듈 시스템
             > 모듈화된 애플리케이션 개발을 가능하게 함
               $ 모듈 : classpath에서 실행되는 대규모 애플리케이션에서 
		 관리하기 어려운 구성 및 캡슐화 문제를 해결

               $ 이점 
                  - 더 작은 실행 파일
                    * 애플리케이션의 의존성을 명확히 정의 할 수 있음
                    * 파일의 크기를 줄일 수 있음
                      # 모듈 패턴 사용
                        > 클래스와 인터페이스를 논리적으로 그룹화
                           $ 불필요한 클래스와 인터페이스를 제외할 수 있음

                      # 불필요한 모듈 제외
                        > 애플리케이션이 사용하지 않는 모듈을 제외
                           $ 이를 위해 jlink툴 사용
                  - 더 나은 성능
                    * 필요하지 않은 모듈은 사용하지 않을 수 있음
                  - 강력한 캡슐화
                     * 캡슐화를 강화하여 액세스를 보다 엄격히 제어
                  - 의존성 관리
                     * 모든 시스템은 라이브러리 의존성을 명확히 정의

               $ 단점 
                  - 모듈 정의의 복잡성
                  - 기존 라이브러리와의 호환성
                  - 모듈 시스템의 학습 곡선
                  - 모듈 패턴 적용의 한계

          # 지속적인 업데이트
             > 2026년 9월까지 제공됨

          # 성능 개선
             > 메모리 사용량 감소
             > GC 기능 개선
               $ Epsilon GC 추가 
                 - GC를 하지 않고 메모리만 할당하고 해제
                   * 특정한 상황에서 메모리 누수 막음
               $ ZGC 개선 
                 - 대규모 시스템에서 빠르고 일관된 GC를 제공 
               $ G1 GC 개선
                 - G1 GC의 성능 개선, Full GC에 걸리는 시간이 줄어듬
               $ CMS GC 개선
                 - CMS GC의 성능이 개선됨

          # 새로운 기능
          # 보안
             > TLS 1.3 지원 
               $ 기본적으로 SSL/TLS 인증서 사용 필요
               $ SSL의 후속버전으로 나온 것
               $ 무료로 사용 가능
               $ 장점 정리하기
             > AppCDS(Application Class Data Sharing)
               $ 이전에 실행된 애플리케이션의 클래스 데이터를 공유해 JVM의 시작 시간 단축
             > ChaCha20 암호화 지원
             > JEP 330
               $ 단일 파일 소스 코드 프로그램을 실행할 수 있는 기능

      - 회사 프론트 
        * 장준혁 선임님
        * 이세경 선임님
        * 최선영 선임님
        * 장희경 책임님
          # Vue js 공부 시작
          # 현재 초기 단계
          # 일정을 정한 뒤 게시판을 만들 일정 물어보기

      - 협업
        * 협업 툴 
          # 게더
            > 사용 이유
               $ 온라인상에서 사람들과 쉽게 만날 수 있음
               $ 영상, 화면공유, 음성채팅, 채팅 구현이 잘되어있음
               $ 쉽게 템플릿을 이용해 방 생성 가능
               $ 게임을 하는 느낌
               $ 여러가지 메모 지원함
               $ 여러명이 한방에 있어도 테이블을 나눠주면 사람들간의 공유가 됨
            > 프로젝트를 진행하며 고려할 사항
               $ 협업을 하면서 배운점?
               $ 회사의 다양한 부서와 이야기할 때 어떻게 대처할 것인가?
          # 피그마
            > 사용 이유
               $ 프론트 개발자들간의 협업을 위한 툴
          # 노션
            > 사용 이유
               $ 프로젝트 설계 진행

      - SSL, TLS 적용
        * Let's Encrypt 사용

      - framework(SpringBoot)
        * dependency  
          # Spring Web 
          # HikariCP
          # lombok 
          # Spring-Transaction
          # Spring Security
          # spring-security-csp
          # spring-boot-starter-validation
            $ 다른 validate 디펜던시도 찾아보기(곽동관 선임 feedback)

        * 기능 구성
          # 인증, 인가 관리
            > XSS(Cross-Site Scripting) 공격을 방지하기 위한 방법
               $ Https 설정
               $ HttpOnly 쿠키 설정 
               $ CSRF(Cross Site Request Forgery) 토큰 활용 
               $ CSP(Content Security Policy) 설정
            > 인증방법
               $ Ajax를 통한 로그인 구현
            > 인가 
               $ Role, Resource를 구분하여 대상자의 권한을 관리
                  - 공부 후 세분화 시킬 필요 있음 
               $ 세션과 쿠키방식 
                  - 서비스별로 차이가 있음

          # DB Connection 관리
            > HikariCP로 Connection Pool을 관리할 때의 이점
               $ 성능향상 
                 - 미리 생성된 연결 풀을 유지하고 관리
               $ 연결 재사용
                 - 애플리케이션에서 데이터베이스 연결을 사용한 후 해당 연결을 다시 연결 풀에 반환
                   * 데이터베이스 부하 감소
               $ 연결 풀 조정
                 - 연결 풀의 크기를 조정할 수 있음
               $ 데이터베이스 연결 관리
                 - 애플리케이션에서 데이터베이스 연결 관리를 하지 않아도 됨

            > Connection 관리 및 보안
               $ JNDI를 통한 datasource관리
                 - 보안
                   * 데이터 베이스 연결 정보를 코드상에 노출하지 X
                   * PasswordEncoder를 통해 단방향 암호화 방식 진행
                   * 해시 알고리즘을 활용해 안전한 암호화
                      # 솔팅(Salting) 과 블럭체인(Chaining) 기법을 사용해 보안성을 높임
                   * 복호화 할수는 없기에 양방향 보단 단방향 암호화 방식이 더 안전함 
                 - 관리 및 유지보수 
                   * 데이터베이스 연결 정보를 서버에 직접 등록함으로 유지보수 측면에서 편리함
                 - 성능 
                   * 데이터 베이스 연결을 캐시하여 애플리케이션 코드에서 매번 연결 생성을 할 필요가 X
                 - 단점
                   * 설정이 어려움

	  $ bashrc(곽동관 선임님, 김영우 책임님 feedback)
                 - Linux Shell 구성파일
                   * 새로운 대화형 bash shell이 열릴 때 마다 읽고 실행됨
                 - bashrc를 이용해 Connection을 관리 할 수 있음
                 - 장점 
                   * 중앙 집중식 관리 
                     # 연결 정보를 어플리케이션 코드가 아닌 bashrc 파일만 업데이트 하면 됨으로 변경에 용이
                   * 보안
                     # 민감한 연결정보를 저장함으로써 bashrc 파일 내의 환경변수에서 정보를 코드와 별도로 유지 가능
                       $ 클라이언트가 리눅스에 접속하지 않은 이상 환경 변수를 확인할 경우 커넥션 정보를 확인할 수 없음
	          $ 리눅스 서버에서 Connection 정보를 암호화 시키는 방법은 없을까?
                       $ 보안을 적용할 대안은?
                   * 재사용성 
                     # 각 애플리케이션에 대해 별도 연결 구성 시간과 노력이 절약됨
                   * 유연성
                     # 사용자의 환경변수를 쉽게 변경 가능함

          # 트랜잭션 관리
            > @EnableTransactionManagement를 통해 Class 단위로 트랜잭션 관리
               - 해당 프로젝트는 트랜잭션을 많이 발생시키지 않을 듯 하지만 
                 오버헤드가 발생 줄이기 위해 클래스별로 트랜잭션을 관리
                 * 당장은 프로젝트에서 트랜잭션을 어떻게 관리하면 좋을지는 모르겠음
                 * 그래서 선택의 기준을 오버헤드 발생량을 줄이는 것을 목표로 함
                 * 당장은 설정 클래스로의 관리를 배제

            > ServiceImpl class별로 @Transactional을 사용해 관리(임요환 선임 feedback)
               - 다수의 사람과 프로젝트 할 경우 가독성이 좋기에 class별로 Transactional을 관리하는 것이 장점
               - 조회되는 부분은 method별로 readonly처리
            
            > Settings 설정을 통해 class(impl)단위로 트랜잭션 관리(김영우 책임 feedback)
               - 클래스 소스가 간결해짐
               - 공통적으로 사용하니깐 확인이 편함
               - 일반적인 설정 방식이라서 편함

          # 유효성 검증 관리
            > 검증 
               참고 경로 : C:\eGovFrameDev-3.10.0-64bit\gradleWorkspace\Study\개인\김영한\MVC2\validation\검증.txt 확인
            > 검증 로직은 ServiceImpl에서 구현 
            > interface Validator를 상속받는 Validation 구현체를 제작
               $ 보안
                 - 클라이언트에서 서버로 데이터를 전송하는 과정에서 데이터가 변경될 수 있음
                   * 데이터 무결성 검증을 위해서 서버에서 작업을 하는 것이 좋음
               $ 관리 및 유지보수 
                 - 클라이언트 로직 변경 및 다른 클라이언트가 검사 로직을 사용할 경우 중복 발생
                    * 이에 서버에서 하나로 관리하는 것이 좋음
             > 수정/저장/삭제별 DTO를 생성
               $ 검증되는 컬럼이 수정/저장시 다를 수 있음

          # 예외 처리
            > 스프링부트가 자동 등록한 BasicErrorController를 활용해 예외 처리 진행
               $ 직관성 
                  - 고객이 직관적으로 이해할 수 있는 페이지 제작
            > 오류는 서버의 로그를 통해 확인할 것

     (1) Version_1_00
        - 게시판 만들기
          * JPA DB, Connection, Validation 초점

